from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from bson import ObjectId
from pymongo import MongoClient
from typing import List, Optional
from datetime import datetime
import google.generativeai as genai
import asyncio
import os
from dotenv import load_dotenv

load_dotenv()

genai.configure(api_key=os.getenv("GCP_API_KEY"))

model = genai.GenerativeModel('gemini-pro')

client = MongoClient(os.getenv("MONGODB_URL"))
db = client["notes_db"]
notes_collection = db["notes"]
templates_collection = db["templates"]

app = FastAPI()

origins = [
    "http://localhost",
    "http://localhost:3000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def health_check():
    return {"status": "healthy"}


# Models
class NoteMetadata(BaseModel):
    session_date: str = Field(..., description="Date of the session")
    client_name: str = Field(..., description="Name of the client")
    note_type: str = Field(..., description="Type of the note (e.g., intake, progress, service)")
    template_id: str = Field(..., description="ID of the template used")
    content: str = Field("", description="Content of the note")
    generated_response: Optional[str] = Field("", description="Generated by Gemini")
    last_updated: Optional[str] = Field("", description="Generated by Gemini")


class NoteResponse(NoteMetadata):
    id: str = Field(..., description="Unique identifier for the note")


class Template(BaseModel):
    name: str = Field(..., description="Name of the template")
    structure: str = Field(..., description="Template structure (e.g., JSON or plain text)")


class TemplateResponse(Template):
    id: str = Field(..., description="Unique identifier for the template")

class PromptRequest(BaseModel):
    # input_note: str
    template_id: str
    note_id: str

class PromptResponse(BaseModel):
    generated_note: str
    template_used: str
    timestamp: datetime
    note_id: str


def serialize_document(document: dict) -> dict:
    """Convert MongoDB ObjectId to string for JSON responses."""
    document["id"] = str(document["_id"])
    del document["_id"]
    return document


@app.get("/api/notes", response_model=List[NoteResponse])
async def get_all_notes():
    """Get all notes."""
    notes = list(notes_collection.find())
    return [serialize_document(note) for note in notes]


@app.get("/api/notes/{note_id}", response_model=NoteResponse)
async def get_note(note_id: str):
    """Get a specific note by ID."""
    note = notes_collection.find_one({"_id": ObjectId(note_id)})
    if not note:
        raise HTTPException(status_code=404, detail="Note not found")
    return serialize_document(note)


@app.post("/api/notes", response_model=NoteResponse)
async def create_note(note: NoteMetadata):
    """Create a new note."""
    if not templates_collection.find_one({"_id": ObjectId(note.template_id)}):
        raise HTTPException(status_code=400, detail="Template not found")
    note_dict = note.dict()
    result = notes_collection.insert_one(note_dict)
    created_note = notes_collection.find_one({"_id": result.inserted_id})
    return serialize_document(created_note)

@app.put("/api/notes/{note_id}", response_model=dict)
async def update_note(note_id: str, updated_data: NoteMetadata):
    """
    Update a specific note by ID.
    """
    if not ObjectId.is_valid(note_id):
        raise HTTPException(status_code=400, detail="Invalid note ID")

    existing_note = notes_collection.find_one({"_id": ObjectId(note_id)})
    if not existing_note:
        raise HTTPException(status_code=404, detail="Note not found")

    # remove empty fields
    updated_note = {k: v for k, v in updated_data.dict().items() if v is not None}

    # Perform the update
    result = notes_collection.update_one(
        {"_id": ObjectId(note_id)},
        {"$set": updated_note}
    )

    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Note not found")

    # Fetch and return the updated note
    updated_note = notes_collection.find_one({"_id": ObjectId(note_id)})
    return serialize_document(updated_note)


@app.delete("/api/notes/{note_id}", response_model=dict)
async def delete_note(note_id: str):
    """Delete a specific note by ID."""
    result = notes_collection.delete_one({"_id": ObjectId(note_id)})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Note not found")
    return {"message": "Note deleted successfully"}


# Templates API
@app.get("/api/templates", response_model=List[TemplateResponse])
async def get_all_templates():
    """Get all templates."""
    templates = list(templates_collection.find())
    return [serialize_document(template) for template in templates]


@app.get("/api/templates/{template_id}", response_model=TemplateResponse)
async def get_template(template_id: str):
    """Get a specific template by ID."""
    template = templates_collection.find_one({"_id": ObjectId(template_id)})
    if not template:
        raise HTTPException(status_code=404, detail="Template not found")
    return serialize_document(template)


@app.post("/api/templates", response_model=TemplateResponse)
async def create_template(template: Template):
    """Create a new template."""
    template_dict = template.dict()
    result = templates_collection.insert_one(template_dict)
    created_template = templates_collection.find_one({"_id": result.inserted_id})
    return serialize_document(created_template)


@app.put("/api/templates/{template_id}", response_model=TemplateResponse)
async def update_template(template_id: str, template: Template):
    """Update an existing template."""
    result = templates_collection.update_one(
        {"_id": ObjectId(template_id)}, {"$set": template.dict()}
    )
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Template not found")
    updated_template = templates_collection.find_one({"_id": ObjectId(template_id)})
    return serialize_document(updated_template)


@app.delete("/api/templates/{template_id}", response_model=dict)
async def delete_template(template_id: str):
    """Delete a specific template by ID."""
    result = templates_collection.delete_one({"_id": ObjectId(template_id)})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Template not found")
    return {"message": "Template deleted successfully"}

@app.post("/api/generate", response_model=PromptResponse)
async def generate_response(request: PromptRequest):
    try:
        # Validate note_id exists
        note = notes_collection.find_one({"_id": ObjectId(request.note_id)})
        if not note:
            raise HTTPException(
                status_code=404,
                detail=f"Note with ID {request.note_id} not found"
            )
        # print('note: ', note)

        template_doc = templates_collection.find_one({"_id": ObjectId(request.template_id)})
        if not template_doc:
            raise HTTPException(
                status_code=404,
                detail=f"Template with ID {request.template_id} not found"
            )
        
        # print('called', note['content'])
        template_string = template_doc["structure"]
        
        formatted_prompt = template_string.format(note=note['content'])
        # print(formatted_prompt)
        
        async def generate_with_gemini():

            model = genai.GenerativeModel(
                'gemini-1.5-flash-8b',
                generation_config=genai.types.GenerationConfig(
                    temperature=0.7,
                    top_p=0.8,
                    top_k=40,
                    max_output_tokens=1000,
                )
            )

            response = await asyncio.to_thread(
                model.generate_content,
                [
                    formatted_prompt,
                ]
            )
            return response.text

        generated_note = await generate_with_gemini()

        current_timestamp = str(datetime.utcnow())

        update_result = notes_collection.update_one(
            {"_id": ObjectId(request.note_id)},
            {
                "$set": {
                    "generated_response": generated_note,
                    "last_updated": current_timestamp
                }
            }
        )

        if not update_result.modified_count:
            raise HTTPException(
                status_code=500,
                detail="Failed to update note with generated response"
            )
        
        result = PromptResponse(
            generated_note=generated_note,
            template_used=template_doc["name"],
            timestamp=current_timestamp,
            note_id=request.note_id
        )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error generating response: {str(e)}"
        )